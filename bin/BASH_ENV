# skip sourcing this file if sourced before, unchanged and not in base repl
(( SHLVL > 1 )) && declare -F "sourced-$(realpath -s ${BASH_SOURCE})" &> /dev/null && ! need "$(realpath -s ${BASH_SOURCE})" && return 0

on.exit() (
    local -i status=$?
    trap - EXIT ERR
    strict
    declare -F finally &> /dev/null && finally
    (( status )) || return 0
    local -i frame=0
    while caller $(( ++frame )) | read -r line subr pathname ; do
        printf '%s@%s:%d\n' ${subr} $(realpath -s ${pathname}) ${line} >&2
    done
    printf 'status => %d\n' ${status} >&2
    return ${status}
)
(( SHLVL > 1 )) && trap on.exit EXIT ERR

identity() ( echo "${1-}"; )

strict() { set -Eeuo pipefail; shopt -s nullglob extdebug lastpipe globstar "$@"; }

non0() ( for a in "$@"; do ! (( a )) && continue; echo ${a}; break; done; )

at() ( strict; printf '%s@%s:%s' $2 ${3:-main} ${1:-0}; )

reqarg() (
    local -i status=$(non0 $3 $? 1)
    strict
    local -i pos=${2:-1}
    local arg="${1:-"arg ${pos}"}"
    caller 1 | read -r line1 subr1 pathname1 || true
    caller 2 | read -r line2 subr2 pathname2 || true
    local message="$(printf '%s: missing required %s (pos %d) # caller %s' "$(at ${line1} ${subr1} ${pathname1})" "${arg}" ${pos}  "$(at ${line1} ${subr1} ${pathname1})" )"
    return $(err "${message}")
)

const() {
    local name="${1:?$(reqarg name 1)}"
    local value="${2:?$(reqarg value 2)}"
    source <(printf 'function %s ( echo "%s"; )' "${name}" "${value}"; )
}

bool() { eval $*; local -i status=$?; echo (( ! status )); return ${status}; }

is.fn() { declare -F "${1:?$(reqarg "bash function name" 1)}" &> /dev/null; }

log() ( : ; )
log.debug() ( : ; )
log.info() ( : ; )
log.warn() ( : ; )
log.err() ( : ; )
warn() ( : ; )
err() ( : ; )
inform() ( : ; )
trace() ( [[ -v TRACE ]] && return 0; shift; log.info "$@"; )
src.fqpn() ( realpath -s "${BASH_SOURCE[1]:-$PWD}"; )
trace "sourcing $(realpath -s ${BASH_SOURCE})"



